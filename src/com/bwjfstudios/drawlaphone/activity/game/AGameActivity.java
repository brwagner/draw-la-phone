package com.bwjfstudios.drawlaphone.activity.game;

import android.os.Bundle;
import android.view.Menu;
import android.view.MenuItem;

import com.bwjfstudios.drawlaphone.R;
import com.bwjfstudios.drawlaphone.activity.AActivity;
import com.parse.ParseException;
import com.parse.ParseObject;
import com.parse.ParseRelation;
import com.parse.ParseUser;

import java.util.List;

/**
 * Abstract class used with draw and write activity
 */
public abstract class AGameActivity extends AActivity {
    private long lastRefreshTime; // Stops User from spamming
    protected abstract Runnable getSendRunnable(); // Generated by subclasses when sending occurs

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        // Assign fields
        this.lastRefreshTime = System.currentTimeMillis();
    }

    void send(Runnable runnable) {
        // Check if the User has attempted to send an answer in the last 10 seconds
        if (System.currentTimeMillis() - this.lastRefreshTime > 10000) {
            // Look Cool
            animateViewSuccess(findViewById(R.id.root));
            // Reset timer
            this.lastRefreshTime = System.currentTimeMillis();
            // Send the data
            getSingletonThread().startThread(runnable);
        }
    }

    // Gets the next user in the turn order
    ParseUser getNextUser(List<ParseUser> users) {
        return users.get(this.getNextIndex(users));
    }

    // Gets the index of the next user in the turn order
    int getNextIndex(List<ParseUser> users) {
        // Iterate until you find the current user and then ++ that index
        for (int i = 0; i < users.size(); i++) {
            if (users.get(i).getObjectId().equals(ParseUser.getCurrentUser().getObjectId())) {
                return (i + 1) % users.size();
            }
        }
        return -1;
    }

    // Is the user the last one in the list
    boolean isEndOfRound(List<ParseUser> users) {
        for (int i = 0; i < users.size(); i++) {
            if (users.get(i).getObjectId().equals(ParseUser.getCurrentUser().getObjectId())) {
                return i == users.size() - 1;
            }
        }
        return false;
    }

    // Performs operations required for control to pass to the next player in the turn order
    protected void moveToNextTurn(ParseObject currentGame) throws ParseException {
        // Transfer control and check if game is complete
        updateGame(currentGame);
        // Save the count of pictures or words for indexing purposes
        incrementIndexedCount(currentGame);
        // Save the game
        currentGame.save();
    }

    // Transfers control to the next player in the turn order and checks if the game is complete
    private void updateGame(ParseObject currentGame) throws ParseException {
        // Get the list of users in this game
        ParseRelation<ParseUser> userRelation = currentGame.getRelation("players");
        List<ParseUser> users = userRelation.getQuery().orderByAscending("objectId").find();
        // Check if the end of the round has been reached
        if (isEndOfRound(users)) {
            // Increase the round number
            currentGame.put("currentRound", currentGame.getInt("currentRound") + 1);
            // Check if the game is over
            if (currentGame.getInt("currentRound") > currentGame.getInt("maxRounds")) {
                currentGame.put("isComplete", true);
            }
        }
        // Make it the next User's turn
        ParseUser nextUser = this.getNextUser(users);
        currentGame.put("currentPlayer", nextUser);
        currentGame.put("currentPlayerName", nextUser.getUsername());
    }

    // Increments picture or word count for indexing purposes
    private void incrementIndexedCount(ParseObject currentGame) {
        currentGame.put(getCountString(), currentGame.getInt(getCountString()) + 1);
    }

    // Gets the Parse key used for lists of pictures and words
    protected abstract String getCountString();

    @Override // Adds action bar
    public boolean onCreateOptionsMenu(Menu menu) {
        // Inflate the menu; this adds items to the action bar if it is present.
        getMenuInflater().inflate(R.menu.draw_write_activity_menu, menu);
        return true;
    }

    @Override // Sets up action bar to send data when the right button is pressed
    public boolean onOptionsItemSelected(MenuItem item) {
        // Handle item selection
        switch (item.getItemId()) {
            case R.id.menu_done:
                this.send(getSendRunnable());
                return true;
            default:
                return super.onOptionsItemSelected(item);
        }
    }
}
